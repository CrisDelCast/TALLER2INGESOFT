pipeline {
    agent any

    environment {
        // Aseg√∫rate de que este MAVEN_OPTS sea adecuado para tu repositorio local
        MAVEN_OPTS = '-Dmaven.repo.local=.m2/repository'
        SERVICE_NAME = 'order-service' // Aseg√∫rate de que esto coincide con el nombre de tu microservicio
        REGISTRY_URL = 'ecommerceacr.azurecr.io' // ¬°CAMBIA ESTO A LA URL COMPLETA DE TU ACR! (ej. miacrdemo.azurecr.io)
        ACR_CREDENTIALS_ID = 'your-acr-jenkins-credentials-id' // ¬°CAMBIA ESTO A 'acr-credentials' o el ID exacto que le diste en Jenkins!
    }

    stages {
        stage('1. Checkout SCM') {
            steps {
                echo 'üì¶ Clonando c√≥digo fuente...'
                checkout scm // Esto utiliza la configuraci√≥n de SCM del Job de Jenkins
            }
        }

        stage('2. Build & Package') {
            steps {
                dir("${SERVICE_NAME}") {
                    echo 'üî® Compilando y empaquetando el proyecto con Maven...'
                    // No uses -X en producci√≥n; es para depuraci√≥n. Lo dejo comentado para que lo uses si lo necesitas.
                    // sh 'mvn clean package -X > maven-build-debug.log 2>&1'
                    sh 'mvn clean package -DskipTests' // Agregamos -DskipTests aqu√≠ para evitar ejecutar tests dos veces o si no hay tests
                }
            }
        }

        stage('3. Unit Tests') {
            steps {
                dir("${SERVICE_NAME}") {
                    echo 'üß™ Ejecutando pruebas unitarias...'
                    sh 'mvn test' // Esta etapa S√ç ejecuta las pruebas
                }
            }
            post {
                always {
                    // Esta secci√≥n se ejecuta SIEMPRE despu√©s de la etapa 'Unit Tests'
                    // Publica los resultados de los tests
                    echo 'üìÑ Publicando resultados de pruebas...'
                    // Aseg√∫rate de que esta ruta sea correcta y que tus tests generen informes XML aqu√≠
                    junit "${SERVICE_NAME}/target/surefire-reports/*.xml"
                }
            }
        }

        stage('4. Build & Tag Docker Image') {
            steps {
                echo 'üê≥ Construyendo imagen Docker...'
                script {
                    env.IMAGE_TAG = "${env.BUILD_NUMBER}" // Usa el n√∫mero de build de Jenkins como tag
                    // Aseg√∫rate de que el Dockerfile del microservicio est√° en la misma carpeta que su pom.xml
                    docker.build("${REGISTRY_URL}/${SERVICE_NAME}:${env.IMAGE_TAG}", "./${SERVICE_NAME}")
                    echo "‚úÖ Imagen construida: ${REGISTRY_URL}/${SERVICE_NAME}:${env.IMAGE_TAG}"
                }
            }
        }

        stage('5. Push Docker Image to ACR') {
            steps {
                echo '‚¨ÜÔ∏è Subiendo imagen a ACR...'
                script {
                    // Utiliza el plugin de Docker para autenticaci√≥n y push, es m√°s seguro y sencillo
                    docker.withRegistry("https://${REGISTRY_URL}", ACR_CREDENTIALS_ID) {
                        def image = docker.image("${REGISTRY_URL}/${SERVICE_NAME}:${env.IMAGE_TAG}")
                        image.push()
                        echo "‚úÖ Imagen enviada: ${REGISTRY_URL}/${SERVICE_NAME}:${env.IMAGE_TAG}"
                    }
                }
            }
        }

        stage('6. Deploy to Kubernetes') {
            steps {
                echo 'üö¢ Desplegando en Kubernetes...'
                script {
                    // Aseg√∫rate de que kubectl est√° configurado para acceder a tu cl√∫ster AKS
                    // Esto usualmente implica montar tu archivo ~/.kube/config en el contenedor Jenkins
                    sh """
                        kubectl set image deployment/${SERVICE_NAME} ${SERVICE_NAME}=${REGISTRY_URL}/${SERVICE_NAME}:${env.IMAGE_TAG} -n default
                        kubectl rollout status deployment/${SERVICE_NAME} -n default
                    """
                    echo "‚úÖ Despliegue completado para ${SERVICE_NAME} con la imagen ${env.IMAGE_TAG}"
                }
            }
        }

        stage('7. Archive Artifacts') {
            steps {
                echo 'üì¶ Archivando artefactos...'
                // Archiva el JAR generado por Maven
                archiveArtifacts artifacts: "${SERVICE_NAME}/target/*.jar", fingerprint: true
            }
        }
    }

    post {
        always {
            echo 'üßπ Limpiando workspace...'
            cleanWs() // Descomentado para limpiar el espacio de trabajo despu√©s de cada build
        }
        success {
            echo '‚úÖ ¬°Pipeline completada con √©xito!'
        }
        failure {
            echo '‚ùå ¬°La pipeline fall√≥!'
        }
    }
}